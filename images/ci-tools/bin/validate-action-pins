#!/usr/bin/env bash
set -euo pipefail

# validate-action-pins — Verify GitHub Actions SHA pins match their claimed tags
#
# Scans workflow files for `uses:` lines pinned to a commit SHA with a tag
# comment (e.g. `actions/checkout@abc123... # v6`) and verifies each SHA
# matches the tag via the GitHub REST API.
#
# Usage:
#   validate-action-pins .github/workflows/*.yml
#   validate-action-pins --help
#   validate-action-pins --version
#
# Environment:
#   GITHUB_TOKEN - (Optional) GitHub token for higher API rate limits
#                  (60 req/hr unauthenticated → 5000 req/hr with token)

readonly PROGRAM="validate-action-pins"
readonly VERSION="${VALIDATE_ACTION_PINS_VERSION:-unknown}"

# ── usage / version ──────────────────────────────────────────────────

usage() {
  cat << 'USAGE'
Usage: validate-action-pins [OPTIONS] FILE...

Verify that GitHub Actions SHA pins match their claimed tags.

Scans workflow files for lines like:
  uses: actions/checkout@de0fac2e... # v6
and checks that the pinned SHA resolves to the stated tag via the GitHub API.

Options:
  --help       Show this help message and exit
  --version    Print the version and exit

Environment:
  GITHUB_TOKEN   Optional token for higher API rate limits
USAGE
}

if [[ $# -eq 0 ]]; then
  usage >&2
  exit 1
fi

for arg in "${@}"; do
  case "${arg}" in
    --help)
      usage
      exit 0
      ;;
    --version)
      echo "${PROGRAM} ${VERSION}"
      exit 0
      ;;
    --) break ;;
    *) ;;
  esac
done

# ── helpers ──────────────────────────────────────────────────────────

FAILURES=0

auth_header=()
if [[ -n "${GITHUB_TOKEN:-}" ]]; then
  auth_header=(-H "Authorization: token ${GITHUB_TOKEN}")
fi

# GitHub API GET with optional auth and error handling.
#
# Arguments:
#   $1 - API URL path (e.g. /repos/owner/repo/git/ref/tags/v1)
#
# Outputs:
#   JSON response on stdout, or empty string on failure
gh_api() {
  local url="https://api.github.com${1}"
  curl -fsSL "${auth_header[@]+"${auth_header[@]}"}" \
    -H "Accept: application/vnd.github+json" \
    "${url}" 2> /dev/null || true
}

# Resolve a tag to its commit SHA, handling both lightweight and annotated tags.
#
# Arguments:
#   $1 - Repository (owner/repo)
#   $2 - Tag name (e.g. v6)
#
# Outputs:
#   40-character commit SHA, or empty string on failure
resolve_tag() {
  local repo="${1}" tag="${2}"

  local ref_json
  ref_json="$(gh_api "/repos/${repo}/git/ref/tags/${tag}")"
  if [[ -z "${ref_json}" ]]; then
    return 1
  fi

  local obj_type obj_sha
  obj_type="$(echo "${ref_json}" | jq -r '.object.type // empty')"
  obj_sha="$(echo "${ref_json}" | jq -r '.object.sha // empty')"

  if [[ -z "${obj_type}" || -z "${obj_sha}" ]]; then
    return 1
  fi

  if [[ "${obj_type}" == "commit" ]]; then
    echo "${obj_sha}"
    return 0
  fi

  # Annotated tag — dereference to the commit.
  if [[ "${obj_type}" == "tag" ]]; then
    local tag_json
    tag_json="$(gh_api "/repos/${repo}/git/tags/${obj_sha}")"
    if [[ -z "${tag_json}" ]]; then
      return 1
    fi
    local commit_sha
    commit_sha="$(echo "${tag_json}" | jq -r '.object.sha // empty')"
    if [[ -n "${commit_sha}" ]]; then
      echo "${commit_sha}"
      return 0
    fi
  fi

  return 1
}

# ── connectivity check ───────────────────────────────────────────────

if ! curl -fsSL "${auth_header[@]+"${auth_header[@]}"}" \
  -H "Accept: application/vnd.github+json" \
  "https://api.github.com/rate_limit" > /dev/null 2>&1; then
  echo "WARN: cannot reach GitHub API — skipping pin validation"
  exit 0
fi

# ── scan and validate ────────────────────────────────────────────────

FOUND_PINS=0

for file in "${@}"; do
  [[ "${file}" == --* ]] && continue
  if [[ ! -f "${file}" ]]; then
    echo "WARN: ${file} not found, skipping"
    continue
  fi

  # Match lines like: uses: owner/repo@<40-hex-sha> # <tag>
  while IFS= read -r line; do
    # Extract owner/repo, SHA, and tag from the uses line.
    if [[ "${line}" =~ uses:[[:space:]]*([^@]+)@([0-9a-f]{40})[[:space:]]*#[[:space:]]*([^[:space:]]+) ]]; then
      action="${BASH_REMATCH[1]}"
      pinned_sha="${BASH_REMATCH[2]}"
      claimed_tag="${BASH_REMATCH[3]}"
      FOUND_PINS=1

      resolved_sha=""
      if resolved_sha="$(resolve_tag "${action}" "${claimed_tag}")"; then
        if [[ "${pinned_sha}" == "${resolved_sha}" ]]; then
          echo "OK   ${action}@${pinned_sha:0:12}... matches ${claimed_tag}"
        else
          echo "FAIL ${action}@${pinned_sha:0:12}... does NOT match ${claimed_tag} (expected ${resolved_sha:0:12}...)"
          FAILURES=$((FAILURES + 1))
        fi
      else
        echo "WARN ${action}@${pinned_sha:0:12}... — could not resolve tag ${claimed_tag}"
      fi
    fi
  done < "${file}"
done

if [[ "${FOUND_PINS}" -eq 0 ]]; then
  echo "No SHA-pinned actions found in the provided files."
fi

if [[ "${FAILURES}" -gt 0 ]]; then
  echo "FAIL: ${FAILURES} pin(s) did not match"
  exit 1
fi
